<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<title>Melbourne Alt .Net 2017 Haskell Workshop</title>
		<link href="resources/css/styles.css"          rel="stylesheet" type="text/css">
		<link href="resources/css/toc.css"             rel="stylesheet" type="text/css">
		<link href="resources/css/fonts.css"           rel="stylesheet" type="text/css">
		<link href="resources/css/solarized-light.css" rel="stylesheet" type="text/css">
	</head>
	<body class="">
		<div id="content">



<div class='chapter'>
<div class='content'>

<h1 id="compose-melbourne-haskell-workshop-2017">Compose :: Melbourne Haskell Workshop 2017</h1>
<div class="center important">
<p>An workshop intended to introduce Haskell to some of the Compose :: Melbourne attendees.</p>
</div>
<div class="important">
<pre class="note notitle"><code>Press &quot;t&quot; to toggle showing the table of contents</code></pre>
</div>
<div class="center nopad">
<img src="resources/images/altnet.png" alt="Workshop" />
</div>
<p>Outcomes include...</p>
<ul>
<li>Creating, editing, running and interacting with Haskell programs</li>
<li>Building the confidence to solve problems in the wild with Haskell</li>
<li>Developing an understanding of the Haskell ecosystem</li>
<li>Interacting with others in a collaborative environment</li>
</ul>
<div class="important note">
<p>Please attempt to have the required items from the <a href="#resources">'Resources'</a> section available for your use during the workshop.</p>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="table-of-contents">Table of Contents</h1>
<div id="toc" class="important">
<!-- Note: This is a special file that determines the order of the chapters                  -->
<!--       The lefthand column refers to the filename of the chapter in 'resources/markdown' -->
<!--       This column is removed before the markdown is processed for the table of contents -->
<!--       ';' is a comment                                                                  -->
<table>
<tbody>
<tr class="odd">
<td align="left"><a href="#required-resources">Resources</a></td>
<td align="left">Resources Available and Required</td>
<td align="left">1m</td>
</tr>
<tr class="even">
<td align="left"><a href="#welcome">Welcome</a></td>
<td align="left">Motivation, Overview, and Approach</td>
<td align="left">15m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#setup">Setup</a></td>
<td align="left">Setting up your Haskell environment</td>
<td align="left">15m</td>
</tr>
<tr class="even">
<td align="left"><a href="#ecosystem">Ecosystem</a></td>
<td align="left">Resources and Community</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#introduction">Introduction</a></td>
<td align="left">Introductory Exercises</td>
<td align="left">30m</td>
</tr>
<tr class="even">
<td align="left"><a href="#types">Types</a></td>
<td align="left">The Haskell Type System</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#adts-algebraic-data-types">ADTs</a></td>
<td align="left">Modelling with data in Haskell</td>
<td align="left">1h</td>
</tr>
<tr class="even">
<td align="left"><a href="#typeclasses">Type-Classes</a></td>
<td align="left">Polymorphism, FP style</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#monads">Monads</a></td>
<td align="left">IO Monad, Do-Notation</td>
<td align="left">1h</td>
</tr>
<tr class="even">
<td align="left"><a href="#lets-make-a-guessing-game">Guessing-Game</a></td>
<td align="left">Let's Make a Guessing Game</td>
<td align="left">1h</td>
</tr>
<tr class="odd">
<td align="left"><a href="#website">Web-Site</a></td>
<td align="left">Making a Web-Site with Scotty</td>
<td align="left">30m</td>
</tr>
<tr class="even">
<td align="left"><a href="#thanks">Thanks</a></td>
<td align="left">Thanks and Goodbye</td>
<td align="left">5m</td>
</tr>
</tbody>
</table>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="required-resources">Required Resources</h1>
<p>Before you begin you will require the following...</p>
<h2 id="a-text-editor" class="important">A Text-Editor</h2>
<p>We are assuming previous programming experience, however, if you would like a recommendation, have a look at <a href="https://atom.io/">Atom</a>, <a href="https://code.visualstudio.com/">Visual Studio Code</a>, <a href="http://www.gnu.org/software/emacs/">Emacs</a> or <a href="http://www.vim.org/">Vim</a>. Just make sure that you are fluent enough to embark on exercises as they appear in the workshop.</p>
<h2 id="stack" class="important"><a href="https://docs.haskellstack.org/en/stable/README/">Stack</a></h2>
<p>In order to run the programs written during this workshop you will need a Haskell installation. The easiest way to get up and running is to install Stack.</p>
<h2 id="a-copy-of-the-workshop-github-project"><a href="https://github.com/sordina/compose_melbourne_2017_haskell_workshop.git">A Copy of the Workshop Github Project</a></h2>
<p>The exercises in the project are available in runnable form in the workshop source.</p>
<p>You can grab the source from GitHub:</p>
<pre class="shell"><code>git clone https://github.com/sordina/compose_melbourne_2017_haskell_workshop.git</code></pre>
<h1 id="other-useful-resources" class="collapse">Other Useful Resources</h1>
<p>These resources are available to help you with any issues you face when learning Haskell:</p>
<h2 id="haskell-on-freenode">#haskell on <a href="http://freenode.net/">Freenode</a></h2>
<p>An IRC channel dedicated to discussion of Haskell. This is often the easiest place to fire off a one-off question that is simple enough not to warrant a permanent listing on the internet.</p>
<h2 id="hackage"><a href="http://hackage.haskell.org/packages/hackage.html">Hackage</a></h2>
<p>Hackage is the primary repository for Haskell packages. It is public, searchable, versioned, and uses Cabal package metadata for classification. Furthermore, this can be used to easily browse package contents, documentation and source-code.</p>
<p>For example, browse the <a href="http://hackage.haskell.org/package/shake">Shake</a> package and look at some of the <a href="http://hackage.haskell.org/packages/archive/shake/0.10.6/doc/html/Development-Shake-Command.html">Modules</a>.</p>
<h2 id="hoogle"><a href="http://www.haskell.org/hoogle/">Hoogle</a></h2>
<p>Hoogle is a Haskell module and function search-engine. Hoogle allows you to take advantage of the granular type-system used by Haskell to search not just for function-names, but for function type-signatures.</p>
<p>For example, have a look for the function with signature <a href="http://www.haskell.org/hoogle/?hoogle=Text+-%3E+ByteString">Text -&gt; ByteString</a>.</p>
<h2 id="rhaskell"><a href="http://www.reddit.com/r/haskell">/r/haskell</a></h2>
<p>For Reddit users, /r/haskell is a very useful resource with a great deal of information regarding recent developments in the Haskell ecosystem and community. This is a good place to ask some more advanced questions or start a flame-war.</p>
<h2 id="learn-you-a-haskell-for-great-good"><a href="http://learnyouahaskell.com/">Learn You a Haskell (For Great Good)</a></h2>
<p>Learn You a Haskell (For Great Good) is a wonderful introductory text on Haskell.</p>
<h2 id="haskell-programming-from-first-principles"><a href="http://haskellbook.com/">Haskell Programming from First Principles</a></h2>
<p>The latest and greatest comprehensive text for learning Haskell.</p>
<h2 id="programming-in-haskell"><a href="http://www.cs.nott.ac.uk/~pszgmh/pih.html">Programming in Haskell</a></h2>
<p>Another well renowned and modern resource for learning Haskell.</p>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="welcome">Welcome</h1>
<div class="important">
<p>Welcome to the Compose :: Melbourne 2017 Haskell Workshop.</p>
<p>The intent of this workshop is to provide a working introduction to Haskell for programmers in Melbourne who have not yet used the language in anger.</p>
<p>The workshop is split into chapters. The chapters will start with a few trivial introductory exercises to get your fingers warmed up, then onto exercises that should be able to be solved using the material introduced up to that point (with help and hints available if needed).</p>
<p>At the beginning of each chapter will be a small listing of terms, so that you know what you can expect to encounter throughout the text of the chapter. This isn't intended to function as a glossary, but simply give you a heads-up on the scope and let you know what's coming up!</p>
<p>Each chapter will conclude with an open-question. This question should provide inspiration for further consideration of how harder problems could be solved using Haskell, and for more advanced attendees, can be attacked instead of twiddling your thumbs after finishing the main exercise.</p>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="setup">Setup</h1>
<p>This section will help you get up and running so that you can participate in the workshop and complete the exercises.</p>
<h2 id="lexicon">Lexicon</h2>
<table>
<thead>
<tr class="header">
<th align="left">-----------</th>
<th align="left">-------------</th>
<th align="left">------------</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Stack</td>
<td align="left">setup</td>
<td align="left">GHCi</td>
</tr>
<tr class="even">
<td align="left">Calculations</td>
<td align="left">$PATH</td>
<td align="left">Loading</td>
</tr>
<tr class="odd">
<td align="left">:reload</td>
<td align="left">Redefine</td>
<td align="left">GHC</td>
</tr>
<tr class="even">
<td align="left">Compile</td>
<td align="left">Optimisation</td>
<td align="left">Install</td>
</tr>
<tr class="odd">
<td align="left">Pointfree</td>
<td align="left">Ecosystem</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<div class="important">
<p>Ensure that you have the following programs installed and functioning correctly:</p>
<h2 id="stack"><a href="https://docs.haskellstack.org/en/stable/README/">Stack</a></h2>
<p>Check that you have stack installed:</p>
<pre class="shell"><code>stack --version</code></pre>
<p>This should output something similar to:</p>
<pre><code>Version 1.1.2 x86_64 hpack-0.14.0</code></pre>
<p>Otherwise, install it!</p>
<h3 id="linux-and-os-x">Linux and OS X:</h3>
<pre class="shell"><code>curl -sSL https://get.haskellstack.org/ | sh
stack setup
stack ghci
Prelude&gt; 1 + 1</code></pre>
<pre class="note"><code>&quot;Prelude&gt; &quot; at the start of a line is a prompt.

Prelude refers to the default values and functions available.

As a convention, anything that starts a line with &quot;&gt; &quot; is a
prompt and if you&#39;re copying and pasting code you should
exclude the &quot;&gt; &quot; and copy to the right of it!</code></pre>
<!-- [Thanks @borsboom](https://github.com/commercialhaskell/stack/issues/3021#event-974900197)
_(If mktemp fails, modify the script, or download stack binary manually.)_
-->
<h3 id="windows">Windows:</h3>
<p>Use the 64-bit installer from <a href="https://docs.haskellstack.org/en/stable/install_and_upgrade/#windows" class="uri">https://docs.haskellstack.org/en/stable/install_and_upgrade/#windows</a>.</p>
<p>Provided you use the 64-bit version, you shouldn't need to worry about the PATH issues.</p>
<p>Then run the following in <code>Cmd</code>:</p>
<pre class="shell"><code>stack setup
stack ghci
Prelude&gt; 1 + 1</code></pre>
<p>This should output:</p>
<pre><code>2</code></pre>
</div>
<pre class="real"><code>You can use GHCi to perform calculations other than just &quot;1 + 1&quot;.

Here is an example session:

Prelude&gt; 1 + 2 + 3
6
Prelude&gt; 100 / 2
50.0
Prelude&gt; 6 ^ 7
279936
Prelude&gt; ^D
Leaving GHCi.</code></pre>
<pre class="note"><code>&quot;^D&quot; refers to holding CONTROL and typing &quot;d&quot;.</code></pre>
<pre class="instruction"><code>Using GHCi...

Calculate the price of 42-bakers-dozens of eggs at $3 per-egg.</code></pre>
<pre class="answer"><code>-- Note that a baker&#39;s dozen is 13!
Prelude&gt; 42 * 13 * 3
1638</code></pre>
<pre class="note"><code>If ghci is on your PATH, then you can invoke it directly,
however, if you have just installed stack, then you will
need to invoke ghci indirectly by calling

&gt; stack exec -- ghci [ARGS]
</code></pre>
<h2 id="loading-files-in-ghci" class="important">Loading files in GHCi</h2>
<p>There are many ways to load and execute Haskell code. For the purposes of this workshop, if you do not already have a workflow you are comfortable with, then we suggest the following steps:</p>
<ul>
<li>Write and edit your programs in files ending in the extension &quot;.hs&quot;</li>
<li>When you are ready to test your program, load it into GHCi</li>
<li>After making modifications to your program, reload the program in GHCi</li>
</ul>
<p>Say you had written the following program <code>test.hs</code>:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>main = print &quot;hello world&quot;
</code></pre>
<p>Load the file in GHCi to see it in action:</p>
<pre class="shell"><code>&gt; stack exec -- ghci test.hs
GHCi, version 7.6.2: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( test.hs, interpreted )
Ok, modules loaded: Main.
Prelude&gt; main
&quot;hello world&quot;</code></pre>
<p>... Unfortunately there is a bug in the program, so in your editor you make the change required to print &quot;hello, world&quot; with the mandated comma:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>main = print &quot;hello, world&quot;
</code></pre>
<p>Now, back in GHCi, you can reload the program without exiting the REPL (Read Eval Print Loop):</p>
<pre class="shell"><code>Prelude&gt; :reload
[1 of 1] Compiling Main             ( test.hs, interpreted )
Ok, modules loaded: Main.
Prelude&gt; main
&quot;hello, world&quot;</code></pre>
<p>Much better!</p>
<pre class="real"><code>You can inspect a value (or function) in ghci with the `:info` command
in order to find out a little about its type and definition:

Prelude&gt; :info main
main :: IO ()   -- Defined at test.hs:1:1

If you just wish to see the type of an expresison, you can use
the `:type` command:

Prelude&gt; :type main
main :: IO ()</code></pre>
<pre class="instruction"><code>

* In the previous example, you defined a function &#39;main&#39;
  that printed &quot;hello, world&quot;...
* .. Now, define a new numeric function that prints something else
* Load it in GHCi
* Test your function in GHCi
* Make a modification
* Reload your chages without exiting GHCi
* Test your changes</code></pre>
<h2 id="ghc" class="important">GHC</h2>
<p>Create the following source file (program.hs):</p>
<pre data-language="haskell"><code>main = print &quot;hello world&quot;</code></pre>
<p>Compile the program as follows:</p>
<pre class="shell"><code>stack exec -- ghc --make program.hs</code></pre>
<p>Run the program with the following command:</p>
<pre class="shell"><code>./program</code></pre>
<p>The output should look as follows:</p>
<pre class="text"><code>&quot;hello world&quot;</code></pre>
<pre class="real"><code>Compiled programs are almost always significantly faster than instructions
run inside GHCi. Even greater speed-ups are possible by using the &quot;-O&quot;
optimisation settings for GHC.</code></pre>
<pre class="instruction"><code>Using GHC...

Compile and run hello-world.</code></pre>
<pre class="answer"><code>&gt; echo &#39;main = print &quot;hello friends&quot;&#39; &gt; main.hs
&gt; stack exec -- ghc --make main.hs
[1 of 1] Compiling Main             ( main.hs, main.o )
Linking main ...
&gt; ./main
&quot;hello friends&quot;</code></pre>
<pre class="open"><code>An open-ended question:

Given that GHC is largely written in Haskell, how was GHC first compiled?</code></pre>
<pre class="open"><code>An open-ended question:

What are some of the current issues with the Haskell ecosystem?</code></pre>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="ecosystem">Ecosystem</h1>
<p>The Haskell ecosystem is large and interesting, it is held together more by convention than by dictation, with the current convention being that open source packages are made available through <code>cabal</code> on Hackage. On top of this distribution, there is a convenient tool provided by Commercial-Haskell called <a href="https://docs.haskellstack.org/en/stable/README/">Stack</a>. Stack builds off the existing ecosystem, but provides stable snapshot releases of compatible packages that makes it easy to install packages that play well together.</p>
<h2 id="lexicon">Lexicon</h2>
<table>
<thead>
<tr class="header">
<th align="left">-----------</th>
<th align="left">-------------</th>
<th align="left">------------</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Stack</td>
<td align="left">install</td>
<td align="left">pointfree</td>
</tr>
<tr class="even">
<td align="left">ghci</td>
<td align="left">new</td>
<td align="left">Hackage</td>
</tr>
</tbody>
</table>
<h2 id="stack">Stack</h2>
<p>The easiest way for newcomers to get started with Haskell these days is by installing Stack via the steps outlined in the <a href="#setup">Setup</a> chapter.</p>
<p>Stack provides a plethora of functionality and you can get an inkling of this by invoking <code>stack --help</code>. However, for the purposes of this workshop you will only really require the use of <code>stack exec --ghci</code>.</p>
<p>The next steps to take would be the installation of libraries and programs via <code>stack install</code> and the creation of new stack projects via <code>stack new</code>.</p>
<pre class="instruction"><code>

Install the pointfree package from stack.

Use the `pointfree` command-line program to to check what the
pointfree version of `\x -&gt; \y -&gt; x + y + 1` is.

Did this seem pointless to you?</code></pre>
<pre class="answer"><code>$ pointfree &#39;\x -&gt; \y -&gt; x + y + 1&#39;

flip flip 1 . ((+) .) . (+)</code></pre>
<pre class="open"><code>An open-ended question:

How would you go about publishing your own package to Hackage?</code></pre>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="introduction">Introduction</h1>
<div class="important">
<p>The following exercises are intended to be used to warm up your fingers, rather than your brain. These should be run through quickly to get you used to using your development environment.</p>
<p>The majority of your workflow should be performed by writing code in an editor, and testing it in GHCi. You will write the definitions in the editor and test them with simple expressions in GHCi.</p>
</div>
<h2 id="lexicon">Lexicon</h2>
<table>
<thead>
<tr class="header">
<th align="left">-----------</th>
<th align="left">-------------</th>
<th align="left">------------</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Primitives</td>
<td align="left">Prelude</td>
<td align="left">Variables</td>
</tr>
<tr class="even">
<td align="left">Literals</td>
<td align="left"><code>let</code></td>
<td align="left">Definitions</td>
</tr>
<tr class="odd">
<td align="left">String</td>
<td align="left">Tuples</td>
<td align="left">Functions</td>
</tr>
<tr class="even">
<td align="left">Invocation</td>
<td align="left">Lists</td>
<td align="left">Infix</td>
</tr>
<tr class="odd">
<td align="left">Cons</td>
<td align="left">(:)</td>
<td align="left">[]</td>
</tr>
<tr class="even">
<td align="left">Destructuring</td>
<td align="left">Pattern-Matching</td>
<td align="left">head</td>
</tr>
<tr class="odd">
<td align="left">Partial</td>
<td align="left">length</td>
<td align="left">map</td>
</tr>
<tr class="even">
<td align="left">Expressiveness</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<h2 id="primitives">Primitives</h2>
<p>Haskell comes pre-packaged with many primitives available in the <code>Prelude</code> module that is included by default. You don't need to know them all right now, but you should at least make yourself familiar with the following types, and literal syntax:</p>
<table style="width:52%;">
<colgroup>
<col width="18%" />
<col width="16%" />
<col width="17%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">What?</th>
<th align="left">Literal Syntax</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Int</td>
<td align="left">Machine Ints</td>
<td align="left">42</td>
</tr>
<tr class="even">
<td align="left">String, [Char]</td>
<td align="left">Strings</td>
<td align="left">&quot;Hello World&quot;</td>
</tr>
<tr class="odd">
<td align="left">Bool</td>
<td align="left">Booleans</td>
<td align="left">True, False</td>
</tr>
</tbody>
</table>
<pre class="real"><code>You can type any literal directly into GHCi in order to have it echoed
right back at you. This may be useful for sanity checking that you have
the syntax right!

ghci&gt; 42
42</code></pre>
<h2 id="variables">Variables</h2>
<p>In Haskell you can define a variable with the <code>=</code> sign.</p>
<p>Variables can be defined at the top-level (no-indentation):</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myVariable = 2
</code></pre>
<p>Variable names should start with a lowercase letter and contain no spaces, or special characters, besides underscores, numbers, and <code>'</code>.</p>
<!--
```real
If you wish to define a variable inside GHCi, you have to prefix
the definition with "let"... For example:

[Prelude] > let myName = "Simon"
```

(Not anymore!!)
-->
<p>Some examples of variable names are:</p>
<ul>
<li><code>a</code></li>
<li><code>my_name</code></li>
<li><code>data43'</code></li>
</ul>
<pre class="instruction"><code>Define your own variable.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>x = &quot;hello&quot;
</code></pre>
<pre class="instruction"><code>What is an example of an invalid variable name?</code></pre>
<pre class="answer nocheck" data-language="haskell"><code>InvalidVariable = 123</code></pre>
<p>String literals look familiar:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myString = &quot;hello world&quot;
</code></pre>
<pre class="instruction"><code>Define a variable containing a string.</code></pre>
<h2 id="tuples">Tuples</h2>
<p>Tuples look like this:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myTuplePair = (1,&quot;hello&quot;)

myTupleTrio = (1,&quot;hello&quot;,3)
</code></pre>
<p>They can be used to group multiple, differently-typed (heterogeneous) values.</p>
<pre class="instruction"><code>Define a variable containing a tuple.</code></pre>
<h2 id="branching">Branching</h2>
<p>In order to decide to make a decision in Haskell you can branch in many different ways. Two simple ways are with <code>if</code> statements, and <code>case</code> statements.</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>sunny = True

umbrellasToBring =
  if sunny
    then 1
    else 0

kindOfBagRequired =
  case umbrellasToBring
    of 0 -&gt; &quot;satchel&quot;
       1 -&gt; &quot;backpack&quot;
       x -&gt; &quot;duffle&quot;
</code></pre>
<p>Another way to perform branching is with <code>pattern-matching</code> which we will discuss shortly.</p>
<p>It's worth noting that Haskell is white-space sensitive. In general, you can add a new-line and indent in-order to continue an expression, however there are several gotchas. See the <a href="https://en.wikibooks.org/wiki/Haskell/Indentation">indentation page on the wiki</a> for more information.</p>
<h2 id="functions">Functions</h2>
<p>Functions are a core part of Haskell. Function definition and invocation look like this:</p>
<pre class="nocheck" data-language="haskell"><code>-- Definition:
myFunction x y ... = ...

-- Invocation:
... myFunction 1 2 ...</code></pre>
<p>This is different to what you might be familiar from a c-familiy language such as Javascript:</p>
<pre class="nocheck" data-language="javascript"><code>// Definition:
function javascriptFunction(a,b ...) { ... }

// Invocation:
javascriptFunction(1,2)</code></pre>
<p>For example:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myAdd x y = x + y
</code></pre>
<p><code>myAdd</code> takes two numbers and returns the result of the addition of those two numbers.</p>
<pre class="note"><code>If you wish to use another function application as an
argument, then you will usually have to enclose it in
a pair of parentheses.

For example:

Prelude&gt; myAdd (myAdd 5 4) 3
12</code></pre>
<pre class="instruction"><code>Define a function `myMultiply` that multiplies 3 numbers.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply x y z = x * y * z
</code></pre>
<pre class="instruction"><code>Use your `myMultiply` function to multiply `4`, `5` and `6734`.</code></pre>
<pre class="answer" data-language="haskell"><code>Prelude&gt; myMultiply 4 5 6734</code></pre>
<pre class="note"><code>There is also an inline-function lambda-syntax:

	\{args...} -&gt; {value}

Here is an example of an &quot;addOne&quot; function:

	Prelude&gt; (\x -&gt; x + 1) 2
	3</code></pre>
<h2 id="pattern-matching">Pattern Matching</h2>
<p>One fairly unique feature of ML family languages like Haskell is a dedicated syntax for &quot;pattern-matching&quot;. Pattern matching is the practice of deconstructing and dispatching on a value at the time of assignment. Deconstruction and dispatching are orthogonal features, but they are often used together. Deconstruction can take the place of a great deal of &quot;accessor-function&quot; style programming, while dispatching can replace many conditional-branching constructs.</p>
<h3 id="deconstruction">Deconstruction</h3>
<p>Drawing on our <code>tuple</code> example, here is a definition that gets the second element of a tuple:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>getSecondElement (e1,e2) = e2
</code></pre>
<p>This would be equivalent to:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>-- `snd` gets the second element of a tuple.
getSecondElementEquiv t = snd t
</code></pre>
<h3 id="dispatch">Dispatch</h3>
<p>Dispatching on a boolean argument instead of using an if statement:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>multiplyByFiveIfTrue x True  = x * 5
multiplyByFiveIfTrue x False = x
</code></pre>
<p>This would be equivalent to:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>multiplyByFiveIfTrue x b  =
  if b then x * 5
       else x
</code></pre>
<p>Another interesting use-case for dispatch is numbers!</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>-- http://mathworld.wolfram.com/AckermannFunction.html
ackermann 0 y = y + 1
ackermann x 0 = ackermann (x-1) 1
ackermann x y = ackermann (x-1) (ackermann x (y-1))
</code></pre>
<h3 id="combining-deconstruction-and-dispatch">Combining Deconstruction and Dispatch</h3>
<p>Here is an example combining both deconstruction and dispatch, but taking a tuple argument with a number in the first position and a boolean in the second. The number is used in the definition, and the boolean is used to dispatch:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>multiplyByFiveIfTrueTuple (x,True)  = x * 5
multiplyByFiveIfTrueTuple (x,False) = x
</code></pre>
<p>This would be equivalent to:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>multiplyByFiveIfTrueTupleEquiv t =
  if (snd t) then (fst t) * 5
             else (fst t)
</code></pre>
<p>While you can use pattern-matching in function-definitions, you can also use it wherever you bind a value, such as case-statements, where and let blocks, and do-notation. You don't have to use pattern-matching in all cases, and sometimes it's easier to just use an <code>if</code> statement. That's fine! Pattern-matching simply looks a little cleaner in some cases.</p>
<h2 id="local-definitions-with-let-and-where">Local Definitions with <code>let</code> and <code>where</code></h2>
<p>If you wish to create local variable definitions in order to simplify your functions or reduce computation, then you can use <code>let</code> bindings:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>amountOfCatFoodLet =
  let
    days = 21
    servingsPerDay = 2
    numberOfCats = 3
    numberOfServings = numberOfCats * servingsPerDay * days
    servingSize = 100 -- grams
  in numberOfServings * servingSize
</code></pre>
<p>Or with <code>where</code> bindings:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>amountOfCatFoodWhere = numberOfServings * servingSize
  where
    days = 21
    servingsPerDay = 2
    numberOfCats = 3
    numberOfServings = numberOfCats * servingsPerDay * days
    servingSize = 100 -- grams
</code></pre>
<h2 id="importing-modules">Importing Modules</h2>
<p>Some functions that you may wish to use aren't part of the Prelude, so you will have to import the modules which they reside in.</p>
<p>This can be done in both your source-code, and GHCi with the <code>import</code> keyword, although the imports in your source have to be close to the top of the file.</p>
<pre class="nocheck" data-language="haskell"><code>import Data.Char                  -- Access to all Data.Char functions
import Data.Char as DCH           -- Name the import for later use
import qualified Data.Char as D   -- Only allow qualified references
import Data.Char (toUpper)        -- Only import a set of functions
import Data.Char hiding (isDigit) -- Hide certain functions</code></pre>
<p>Try using <a href="https://www.haskell.org/hoogle/">Hoogle</a> to search for functions and the modules where they live!</p>
<pre class="note"><code>An example of using module imports:

Prelude&gt; import Data.Char (toUpper)
Prelude&gt; reverse (map toUpper &quot;hello&quot;)
&quot;OLLEH&quot;</code></pre>
<h2 id="lists">Lists</h2>
<p>Lists are a commonly used data-structure in Haskell. Everything in a list has the same type (they are homogeneous).</p>
<p>Lists are built using the infix data-constructor <code>(:)</code> (pronounced &quot;cons&quot;). They also have a compact notation using <code>[...]</code>.</p>
<p>List literals look like:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>list1 = [1,2,3]
list2 = 1 : 2 : []
list3 = &quot;hello&quot; : &quot;world&quot; : []
</code></pre>
<p>More information about why lists can be used the way that they are is contained in the <a href="#adts-algebraic-data-types">ADTs</a> chapter.</p>
<pre class="instruction"><code>Define a variable containing a list.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myList = [1,2,3]
</code></pre>
<p>You can deconstruct a list by pattern matching the head and tail as in the case of this function definition:</p>
<pre class="nocheck" data-language="haskell"><code>f (x:xs) = something something ...</code></pre>
<pre class="instruction"><code>Define a function to get the first element of a list.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myHead (x:xs) = x -- This is a partial function, Beware!
</code></pre>
<p>In <code>Prelude</code> this function is called <code>head</code>.</p>
<pre class="note"><code>&quot;head&quot; is a partial function - It will raise an exception if
called with an empty list.

In Haskell we generally wish to avoid defining partial functions.</code></pre>
<pre class="instruction"><code>

Define a variable containing the first element of your list.

Make use of your myHead function in the definition!</code></pre>
<pre class="answer nocheck" data-language="haskell"><code>myFirstElement = myHead myList</code></pre>
<h3 id="define-length">Define Length</h3>
<pre class="instruction"><code>Define a function that takes a list and returns the length.</code></pre>
<p>Your solution should have the form of:</p>
<pre class="nocheck" data-language="haskell"><code>myLength []     = ...
myLength (x:xs) = ...</code></pre>
<p>Things to consider:</p>
<ul>
<li>What is the length of an empty list? (the base case)</li>
<li>What is the length of something with an additional element?</li>
<li>What is the length of xs? Can you use a function for this?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myLength []     = 0
myLength (x:xs) = 1 + myLength xs
</code></pre>
<pre class="note"><code>Repeated definitions with different argument structures,
such as myLength, is called &quot;pattern-matching&quot;. This is
because each line &quot;matches&quot; the &quot;pattern&quot; of its arguments.</code></pre>
<h3 id="define-mymap">Define <code>myMap</code></h3>
<pre class="instruction"><code>

Define a function &quot;myMap&quot; that takes a function-argument and a list,
and returns a new list containing the result of the function-argument
applied to each element of the list-argument.</code></pre>
<p>Some concrete examples of such a function may do the following:</p>
<ul>
<li>Take a function that divides integers by two, list of ints, and returns a list of doubles.</li>
<li>Take a function that turns lowercase into uppercase characters, and a String, and returns a string in CAPS. Such an uppercasing function can be found in the <code>Data.Char</code> module named <code>toUpper</code>.</li>
</ul>
<p>Things to consider:</p>
<ul>
<li>What is the base-case of myMap?</li>
<li>What is the inductive-case of myMap?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMap f [] = []
myMap f (x:xs) = f x : myMap f xs
</code></pre>
<h3 id="combining-lists">Combining Lists</h3>
<p>Lists can be combined by using the <code>++</code> function. This is an infix function similar to <code>+</code>.</p>
<pre class="instruction"><code>

Define a new &quot;betterList&quot; combining your &quot;myList&quot; list with itself
to make it twice as good!</code></pre>
<pre class="answer" data-language="haskell"><code>betterList = myList ++ myList</code></pre>
<h2 id="fun-list-functions">Fun List Functions</h2>
<p>For your reading pleasure, here are some definintions of other common functions:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myFilter f []     = []
myFilter f (x:xs) = if f x then x : myFilter f xs
                           else     myFilter f xs

myFold f z []     = z
myFold f z (x:xs) = f x (myFold f z xs)

myReverse []     = []
myReverse (x:xs) = myReverse xs ++ [x]

myElem e []     = False
myElem e (x:xs) = if e == x then True
                            else myElem e xs
</code></pre>
<pre class="open"><code>An open-ended question:

What is a good balance between safety and expressiveness in a
programming-language?</code></pre>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="types">Types</h1>
<pre class="note.notitle"><code>Question: How do you create a great program?
Answer:   You type it!</code></pre>
<p>In this chapter, we will go over the exercises from the introduction and add types to the examples.</p>
<h2 id="lexicon">Lexicon</h2>
<table>
<thead>
<tr class="header">
<th align="left">-----------</th>
<th align="left">-------------</th>
<th align="left">------------</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Type</td>
<td align="left">Signature</td>
<td align="left">Inline</td>
</tr>
<tr class="even">
<td align="left">Int</td>
<td align="left">::</td>
<td align="left">Floating</td>
</tr>
<tr class="odd">
<td align="left">Variable</td>
<td align="left">Synonym</td>
<td align="left">String</td>
</tr>
<tr class="even">
<td align="left">Tuple</td>
<td align="left">Function</td>
<td align="left">(,)</td>
</tr>
<tr class="odd">
<td align="left">C</td>
<td align="left">Argument</td>
<td align="left">Curried</td>
</tr>
<tr class="even">
<td align="left">Parentheses</td>
<td align="left">Multiply</td>
<td align="left">Lists</td>
</tr>
<tr class="odd">
<td align="left">Around-Fix</td>
<td align="left">Prefix-Form</td>
<td align="left">Deconstruction</td>
</tr>
<tr class="even">
<td align="left">head</td>
<td align="left">length</td>
<td align="left">map</td>
</tr>
</tbody>
</table>
<h2 id="types-1">Types</h2>
<p>In Haskell, values have associated types. What this means is that any particular value can have its type reasoned about statically. But what is a type? There are primitive types, type-builders, and user-defined types. These make available a parallel language for expressing, reasoning about, and constraining different types. The value-level language and the type-level language are linked in several different ways. One is that through &quot;inference&quot; the types of your expressions have to &quot;make sense&quot;. Another way is the explicit type-signatures that you can give you values.</p>
<h2 id="signatures">Signatures</h2>
<p>Type signatures can be provided inline, or above definitions. Primitive types generally start with a capital letter. The general format goes something like this:</p>
<pre data-language="haskell"><code>value :: { signature }
value { definition }</code></pre>
<p>In English, you can read this as...</p>
<blockquote>
<p>value is of type { signature }...</p>
</blockquote>
<p>For example:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>x :: Int
x = 3
</code></pre>
<p>or</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>x = (3 :: Int)
</code></pre>
<p>It is far more common to place the type-signature above the definition, with inline types only used in situations where ambiguities need to be resolved.</p>
<div class="important">
<pre class="instruction nobefore"><code>You are defining a floating point variable:</code></pre>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myFloat = 1.1
</code></pre>
<pre class="instruction"><code>Give your variable a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myFloat :: Float
myFloat = 1.1
</code></pre>
</div>
<h2 id="type-synonyms">Type Synonyms</h2>
<p>In Haskell, we can give type-expressions an alias (or synonym) by using the <code>type</code> keyword. This allows you to cut down the verbosity and chance of errors in your code when you have type expressions that would otherwise be repeated frequently.</p>
<p>An example of this is the <code>String</code> type-synonym, which is defined as follows:</p>
<pre class="nocheck" data-language="haskell"><code>type String = [Char]</code></pre>
<pre class="instruction"><code> 

Give your &quot;myString&quot; variable from the previous chapter a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myString :: String
myString = &quot;Hello Haskell&quot;
</code></pre>
<h2 id="tuples">Tuples</h2>
<p>Tuple type signatures look the same as the tuples themselves, with types in place of the data.</p>
<p>For example, if you had a tuple of a String and an Int, the type would look as follows:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myTuple :: (String, Int)
myTuple = (&quot;The meaning of life&quot;, 42)
</code></pre>
<pre class="instruction"><code>Give your previous &quot;myTuplePair&quot; definition a type signature.</code></pre>
<h2 id="type-variables">Type-Variables</h2>
<p>Most primitive-types in a type-signature are expressed with upper-case names. However, if you want to indicate that a type is repeated in a signature, but don't want to lock down what the type is, then you can use a lower-case type-variable.</p>
<p>For example, if we wanted a tuple to have the same type of element in each position, then we could write the following:</p>
<pre class="nocheck" data-language="haskell"><code>... (a,a) ...</code></pre>
<p>This becomes especially important in the context of functions!</p>
<h2 id="functions">Functions</h2>
<p>The type signatures of functions in Haskell are a little different from how they look in the more familiar C family languages, but the syntax is very elegant and will allow a higher-level of reasoning than less consistent forms.</p>
<p>The syntax for a function type-signature is of the form:</p>
<pre class="nocheck" data-language="haskell"><code>{functionName} :: {argument} -&gt; {result}</code></pre>
<p>The main idea is that functions in Haskell only ever take one argument. If you wish to define a function that takes more than one argument, then you should, in fact, define a function that takes one argument, then returns another function.</p>
<p>Luckily the syntax for doing this in Haskell looks identical to defining a multi-argument function:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply x y z = x * y * z
</code></pre>
<p>However, the distinction becomes clear with the type-signature:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply :: Int -&gt; (Int -&gt; (Int -&gt; Int))
myMultiply x y z = x * y * z
</code></pre>
<pre class="note"><code>If you ask for info of your multiply function before
giving it a type-signature, you will see references to
&quot; Num =&gt; &quot;... Ignore that for now, we will cover it in
the type-classes chapter!</code></pre>
<p>Now we can see that the function only takes one argument, then returns a function (that only takes one argument, and returns a function (that only takes one argument, that returns an Int.))</p>
<p>This is known as currying.</p>
<p>Fortunately, Haskell's function syntax is right-associative, allowing us to drop the parentheses:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply :: Int -&gt; Int -&gt; Int -&gt; Int
myMultiply x y z = x * y * z
</code></pre>
<p>... and the syntax for function-application works well with this idea too!</p>
<pre class="instruction"><code>

Define a &quot;myMultiplyB&quot; function that multiplies 4 numbers.

Make sure to give your function a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiplyB :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int
myMultiplyB w x y z = w * x * y * z
</code></pre>
<h2 id="lists">Lists</h2>
<p>List type-signatures look like:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>list1 :: [Int]
list2 :: [Int]
list3 :: [String]

list1 = [1,2,3]
list2 = 1 : 2 : []
list3 = &quot;hello&quot; : &quot;world&quot; : []

list1A :: ([]) Int -- Very rarely used syntax!
list1A = [1]
</code></pre>
<pre class="note"><code>Comments in Haskell start with &quot;--&quot; for single-line,
and &quot;{- ... -}&quot; for multi-line.</code></pre>
<p>List type signatures are special in that the type-constructor is &quot;Around&quot;-fix. This is not generally possible, and lists are a special case in that regard.</p>
<p>If you find you need to, you can use the list type in prefix-form, as per variable <code>list1A</code>.</p>
<pre class="instruction"><code>Define a list variable and give it a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myList :: [Int]
myList = [1,2,3]
</code></pre>
<pre class="instruction"><code>Give your `head` deconstructor function a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myHead :: [a] -&gt; a
myHead (x:xs) = x
</code></pre>
<h3 id="length-signature">Length Signature</h3>
<pre class="instruction"><code>Give your length function a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myLength :: [a] -&gt; Int
myLength []     = 0
myLength (x:xs) = 1 + myLength xs
</code></pre>
<h3 id="map-signature">Map Signature</h3>
<pre class="instruction"><code>Give your `map` function a type-signature.</code></pre>
<p>Things to consider:</p>
<ul>
<li>What is the type of the first argument of myMap?</li>
<li>What is the second argument, etc?</li>
<li>What is the type of the result of myMap?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMap :: (a -&gt; b) -&gt; [a] -&gt; [b]
myMap f [] = []
myMap f (x:xs) = f x : myMap f xs
</code></pre>
<h2 id="fun-list-functions-types">Fun List Functions Types</h2>
<p>Here are the types for the definintions of the list functions from the previous chapter:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myFilter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
myFilter f []     = []
myFilter f (x:xs) = if f x then x : myFilter f xs
                           else     myFilter f xs

myFold :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
myFold f z []     = z
myFold f z (x:xs) = f x (myFold f z xs)

myReverse :: [a] -&gt; [a]
myReverse []     = []
myReverse (x:xs) = myReverse xs ++ [x]

myElem :: Eq a =&gt; a -&gt; [a] -&gt; Bool
myElem e []     = False
myElem e (x:xs) = if e == x then True
                            else myElem e xs
</code></pre>
<pre class="instruction"><code>Try to understand the type-signatures for these functions.

Hint: Try finding a way to say them in English.</code></pre>
<pre class="open"><code>An open-ended question:

How many types could a type-checker check...
... if a type checker could check types?</code></pre>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="adts-algebraic-data-types">ADTs (Algebraic Data Types)</h1>
<div class="center">
<p><a href="http://www.haskell.org/haskellwiki/Algebraic_data_type">Haskell Wiki Link</a></p>
</div>
<p>Algebraic Data Types are THE bread and butter of Haskell programs.</p>
<ul>
<li>Functions evaluate data by pattern-matching against ADTs</li>
<li>Problem-domains are modeled using ADTs</li>
<li>Laziness is linked to ADTs</li>
<li>Types can be derived from ADT definitions</li>
</ul>
<div class="collapse">
<p>But how does that help me?</p>
<h2 id="lexicon">Lexicon</h2>
<table>
<thead>
<tr class="header">
<th align="left">-----------</th>
<th align="left">-------------</th>
<th align="left">------------</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">ADT</td>
<td align="left">Algebraic</td>
<td align="left">Laziness</td>
</tr>
<tr class="even">
<td align="left">Types</td>
<td align="left">Modelling</td>
<td align="left">Bool</td>
</tr>
<tr class="odd">
<td align="left">Enum</td>
<td align="left">C++</td>
<td align="left">Parameter</td>
</tr>
<tr class="even">
<td align="left">Constructor</td>
<td align="left">Recursive</td>
<td align="left">Concrete</td>
</tr>
<tr class="odd">
<td align="left">Kind</td>
<td align="left">*</td>
<td align="left">String</td>
</tr>
<tr class="even">
<td align="left">Int</td>
<td align="left">Maybe</td>
<td align="left">[]</td>
</tr>
<tr class="odd">
<td align="left">IO</td>
<td align="left">(-&gt;)</td>
<td align="left">Deriving</td>
</tr>
<tr class="even">
<td align="left">data</td>
<td align="left">Show</td>
<td align="left">Type-Class</td>
</tr>
<tr class="odd">
<td align="left">List</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<h2 id="example">Example</h2>
<p>An example of an ADT in Haskell:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyBool = MyTrue | MyFalse | MyNotSure

should_I_eat_something_bigger_than_my_own_head :: MyBool
should_I_eat_something_bigger_than_my_own_head = MyFalse
</code></pre>
<pre class="real"><code>With this functionality, you are able to introduce your own &quot;Enum&quot;
values.

The MyBool example is somewhat equivalent to the following C++ code:

enum MyBool { MyTrue, MyFalse, MyNotSure };

With the added bonus of not having out-of-bounds casting ruin your day.

If your problem space can be modeled using various discrete values,
then this form of ADT will allow you to create a program that mirrors
your problem!</code></pre>
<p>You can add parameters to the data constructors:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyNullString = Nada | MyString String

stringy :: MyNullString
stringy = MyString &quot;Whatever, It&#39;s just a string&quot;

blanky :: MyNullString
blanky = Nada
</code></pre>
<p>Constructors can take multiple parameters:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data SomeJunk = Rubbish String | TrashPile String Int Bool

discards :: SomeJunk
discards = TrashPile &quot;Junk Yard&quot; 42 True
</code></pre>
<p>Furthermore, ADTs can be recursive:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyNumberList = Nada | SomeNumbers Int MyNumberList

numbers :: MyNumberList
numbers =  SomeNumbers 1 (SomeNumbers 2 Nada)
</code></pre>
<p>Finally, ADTs can be parametrised by other types:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyContainer x = Jar x

contained :: MyContainer Int
contained = Jar 1

pun :: MyContainer (MyContainer String)
pun = Jar (Jar &quot;Binks&quot;)
</code></pre>
<p>In general, the syntax of an ADT looks similar to the following:</p>
<pre class="bnf"><code>ADT          := data &lt;TypeName&gt; &lt;Variables&gt; = &lt;Constructors&gt;
TypeName     := [A-Z] + [a-z&#39;_]*
Parameters   := &lt;ConcreteType&gt; + (&quot; &quot; + &lt;ConcreteType&gt;)*
Constructors := &lt;Constructor&gt; + (&quot; | &quot; + &lt;Constructor&gt;)*
Constructor  := &lt;TypeName&gt; + &lt;Parameters&gt;
Variables    := &lt;Variable&gt; + (&quot; &quot; + &lt;Variable&gt;)*
Variable     := [a-z] + [a-z&#39;_]*</code></pre>
<p>ConcreteType can't be defined syntactically, but it means that your type is &quot;Fully Applied&quot; (in Haskell terms, of <strong>kind</strong> <code>*</code>). An example of some concrete types are:</p>
<ul>
<li><code>String</code></li>
<li><code>Int</code></li>
<li><code>Maybe String</code></li>
<li><code>[Int]</code></li>
</ul>
<p>Examples of some non-concrete types are:</p>
<ul>
<li><code>Maybe</code></li>
<li><code>IO</code></li>
<li><code>(-&gt;)</code></li>
</ul>
<h2 id="deriving">Deriving</h2>
<p>One final thing to note is that in order to be able to print values of your data types at the GHCi REPL, you will need your data to be a member of the <code>Show</code> type-class.</p>
<p><em>Type-classes are covered in depth in the <a href="#typeclasses">type-classes</a> chapter.</em></p>
<p>This is achieved by appending the following text after your data definition:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyData = SuperGreat deriving (Show)
</code></pre>
<p>Similar classes are needed for ordering and equality. If you get stuck on a missing class, just add the following deriving triple for now:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyData = SuperGreat deriving (Eq, Ord, Show)
</code></pre>
<h2 id="exercises">Exercises</h2>
<p>With all of this power at your disposal, it's time to define a list ADT yourself.</p>
</div>
<pre class="instruction"><code>Define your own generic list ADT.</code></pre>
<p>Things to consider:</p>
<ul>
<li>Should this ADT be parametrised?</li>
<li>Should this ADT be recursive?</li>
<li>Should this ADT have multiple constructors?</li>
<li>Should the constructors be parametrised?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyList a = Empty | Items a (MyList a)
</code></pre>
<pre class="open"><code>An open-ended question:

What would the ADT for a Lisp-like language look like?</code></pre>
<div class="note">
<p>If you wish to learn about why ADTs are &quot;Algebraic&quot;, then have a look at:</p>
<ul>
<li><a href="http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/">The Algebra of Algebraic Data Types, Part 1</a></li>
<li><a href="http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/">The Algebra of Algebraic Data Types, Part 2</a></li>
<li><a href="http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/">The Algebra of Algebraic Data Types, Part 3</a></li>
</ul>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>

<h1 id="typeclasses">Type Classes</h1>
<p>A big part of writing clean reusable code is controlled polymorphism. We are like a carny at the roller-coaster, anybody can ride the roller coaster, but you must be at least this tall.</p>
<p>In the object oriented world we use the inheritance heirachy, we know that if something is a subclass, it has at least all of the features of its parent. Of course this is all intertwined with the sharing of data and state, and that's bad.</p>
<h2 id="lexicon">Lexicon</h2>
<table>
<thead>
<tr class="header">
<th align="left">-----------</th>
<th align="left">-------------</th>
<th align="left">------------</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Polymorphism</td>
<td align="left">Object-Oriented</td>
<td align="left">Inheritance</td>
</tr>
<tr class="even">
<td align="left">Data</td>
<td align="left">State</td>
<td align="left">Type-Classes</td>
</tr>
<tr class="odd">
<td align="left">Functions</td>
<td align="left">Context</td>
<td align="left">=&gt;</td>
</tr>
<tr class="even">
<td align="left">Num</td>
<td align="left">(+)</td>
<td align="left">Show</td>
</tr>
<tr class="odd">
<td align="left">Read</td>
<td align="left">String</td>
<td align="left">return</td>
</tr>
<tr class="even">
<td align="left">Dispatch</td>
<td align="left">(::)</td>
<td align="left">Definition</td>
</tr>
<tr class="odd">
<td align="left">Instance</td>
<td align="left">Declaration</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<h2 id="functional-type-classes">Functional Type-Classes</h2>
<p>In the functional world we get type classes, which is just controlled polymorphism without the baggage. They basically say, that I don't need to know exactly what type you'll call me with but you need to provide a bunch of functions for me to use.</p>
<p>A function tells you what type classes it needs with a &quot;context&quot;, The context is the bit to the left of the double arrow &quot;=&gt;&quot;</p>
<pre class="nocheck" data-language="haskell"><code>(+) :: Num a =&gt; a -&gt; a -&gt; a

show :: Show a =&gt; a -&gt; String</code></pre>
<p>In the above example, we have <code>(+)</code>. It can work for any type that is a number. There are built in types for numbers and you can also define your own.</p>
<p><code>show</code> can turn any &quot;Showable&quot; type into a string. this is analogous to the <code>toString()</code> method in Java.</p>
<pre class="instruction"><code>

Define a function that adds one to everything in a list.

What is the type of this function?</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>incrementer :: Num a =&gt; [a] -&gt; [a]
incrementer l = map (+1) l
</code></pre>
<p>Unlike most other languages, with some kind of type driven function dispatch (e.g. methods, overloading). Haskell can also use the <em>return</em> type of the function to choose functionality, this can take a little getting used to, but it is powerful.</p>
<pre class="nocheck" data-language="haskell"><code>read :: Read a =&gt; String -&gt; a

incrementAndshow :: (Num a, Show a) =&gt; a -&gt; String</code></pre>
<p><code>read</code> turns a string into a value of another type, although we don't know what this is yet. It depends, for example on the type of the function that you are passing the result of read into.</p>
<p><code>incrementAndShow</code> demonstrates a function that uses two type classes in its context.</p>
<pre class="instruction"><code>

Convert a string to an integer using read, then covert
a string into a list of integers using read.

Hints:

* Use (::) to add a type to an expression inline
* If you want to know the format required for your string,
  then try showing the value you would like to end up with.

If you just type &#39;read &quot;1&quot;&#39; in ghci you get an error, why is this?</code></pre>
<pre class="instruction"><code>

Define `incrementAndShow` which adds one to a number and
coverts it to a string.

What is they type of this function?

How did haskell infer your context?</code></pre>
<h1 id="defining-your-own-type-classes">Defining Your Own Type Classes</h1>
<p>Let's define a type class of things that can be rated, as in 1 to 5 stars or awesome to lame.</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>
data Rating = 
  SoAwesomeICried |
  PrettyCool      |
  Meh             |
  ForTheLoveOfGodMakeItEnd
  deriving Show

class Rateable r where
  rating :: r -&gt; Rating


data Beer = Coopers | Fosters | CarltonDraught
  deriving Show

instance Rateable Beer where
  rating Coopers = PrettyCool
  rating Fosters = ForTheLoveOfGodMakeItEnd
  rating CarltonDraught = Meh


data Movie = Movie String
  deriving Show

instance Rateable Movie where
  rating (Movie &quot;Bladerunner&quot;) = SoAwesomeICried
  rating (Movie &quot;Tron&quot;) = PrettyCool
  rating _ = Meh

</code></pre>
<p>When we define a type class we write out the name and the types of the functions that we want associated with this type class. We also put a type variable in our definition which refers to whatever type may instance this type class later. We can use this type variable in the definitions below. At this point we can also define default definitions for the functions.</p>
<p>We then define two new data types, <code>Beer</code> and <code>Movie</code> for which we add an &quot;instance declaration&quot; this is where we write the definitions of the type class functions specialized for beers of movies.</p>
<p>We now know how to manually add type class definitions and we could add custom <code>Show</code> instances for each of our new datatypes. However this would be a bunch of boilerplate nonsense, so we can use the handy deriving directive to automatically add a <code>Show</code> instance for us.</p>
<pre class="instruction"><code>Create your own Rateable type class and wacky Rating datatype.
Then create datatypes and instances for something you have a
strong opinion about, like cars or a political party.</code></pre>
<pre class="instruction"><code>Add a review function to your type class that returns
a short textual review.</code></pre>
<pre class="instruction"><code>Add a Rateable instance for a native type, like String.</code></pre>
<p>There are a few other cool things you can do with typeclasses that are not covered here. So if you want to know more, check out some of these other articles:</p>
<p><a href="http://www.haskell.org/tutorial/classes.html" class="uri">http://www.haskell.org/tutorial/classes.html</a></p>

</div>
</div>




<div class='chapter'>
<div class='content'>

<h1 id="monads">Monads</h1>
<h2 id="lexicon">Lexicon</h2>
<table>
<thead>
<tr class="header">
<th align="left">-----------</th>
<th align="left">-------------</th>
<th align="left">------------</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Monad</td>
<td align="left">Rules</td>
<td align="left">Side-Effects</td>
</tr>
<tr class="even">
<td align="left">Tainted</td>
<td align="left">Function</td>
<td align="left">IO</td>
</tr>
<tr class="odd">
<td align="left">Bind</td>
<td align="left">(&gt;&gt;=)</td>
<td align="left">Specialised</td>
</tr>
<tr class="even">
<td align="left">main</td>
<td align="left">getLine</td>
<td align="left">Isomorphic</td>
</tr>
<tr class="odd">
<td align="left">Inside</td>
<td align="left">Unwrapped</td>
<td align="left">&quot;and-then&quot;</td>
</tr>
<tr class="even">
<td align="left">return</td>
<td align="left">lift</td>
<td align="left">Vanilla</td>
</tr>
<tr class="odd">
<td align="left">Interleaved</td>
<td align="left">do</td>
<td align="left">&lt;-</td>
</tr>
<tr class="even">
<td align="left">DSL</td>
<td align="left">Desugar</td>
<td align="left">AI</td>
</tr>
<tr class="odd">
<td align="left">Pure</td>
<td align="left">sequence</td>
<td align="left">forever</td>
</tr>
<tr class="even">
<td align="left">mapM</td>
<td align="left">CQRS</td>
<td align="left">Transform</td>
</tr>
<tr class="odd">
<td align="left">Compose</td>
<td align="left">Explicit</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<h2 id="no-seriously-what-are-monads">No seriously, what are Monads?</h2>
<p>A monad is just a bunch of rules. There are many, many analogies for monads out there. Each of these analogies are useful, but can be obscuring on their own, they are just one view point. To effectively wield monads we must use many different view points together, each one revealing a little piece of the underlying structure of monads. Each view point becomes another tool in our mental toolbox.</p>
<p>So there is no one magic-bullet analogy for monads, only many complementary ones.</p>
<p>Haskell uses monads to represent side-effects. The simplest and most practical analogy is the &quot;tainted value&quot; analogy. In Haskell the function that reads a file looks like this:</p>
<pre class="nocheck" data-language="haskell"><code>readFile :: FilePath -&gt; IO String</code></pre>
<p>This function can't return a normal string, because the return value has been tainted by side effects. So the IO monad is acting as a tag saying that the returned string must be treated specially.</p>
<p>But an <code>IO String</code> is not very useful to us, because we want to actually do things with it. So Haskell, in its normal paternalistic style, allows us access the <code>String</code> inside an <code>IO String</code> only in a very careful way. We use an operation call bind <code>(&gt;&gt;=)</code> to access the string.</p>
<pre class="nocheck" data-language="haskell"><code>(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b

-- Here specialized for IO and String

(&gt;&gt;=) :: IO String -&gt; (String -&gt; IO b) -&gt; IO b</code></pre>
<p>This says the only way we can &quot;look inside&quot; an <code>IO String</code> is by providing a function that takes a <code>String</code> and returns some other new value that has also been tainted by the outside world. In other words we can only look at a value &quot;inside&quot; the <code>IO</code> monad if we promise to make sure our result will also be tainted.</p>
<p>This means that if some code uses a value from the outside world, even deep inside, it cannot be hidden, it must be made explicit in the type. Tainting is a one way street, once you are tainted you can't be untainted. There is no function <code>untaint :: IO a -&gt; a</code>. One can't get an untainted value from a tainted one.</p>
<p>In fact, in haskell, the very way we construct a useful program is by ultimately creating value of type <code>IO ()</code> that we assign to special variable called <code>main</code>.</p>
<pre class="instruction"><code>

Why can&#39;t one write untaint?

If you could what problems would this cause?</code></pre>
<pre class="note"><code>Aside from &quot;tainting&quot; another way to think about the
&quot;IO&quot; type is as little side-effectful imperative programs.

You can create a new program that sends the output of one
of these programs into the input of another one using
the &quot;&gt;&gt;=&quot; function.

Just like all other values in Haskell, these IO values can
be passed around, duplicated, put in lists, etc. The
interesting thing is that the only way that they can actually
run is by assigning one to a &quot;main&quot; function.
(or calling one from GHCi)...</code></pre>
<p>One thing that can be a little strange is the type of <code>getLine</code>. In imperative languages, functions of zero arguments make some sense. They can be thought of recipies or to-do lists. In haskell a total function of type <code>() -&gt; Foo</code> is isomorphic to a constant <code>Foo</code>. Because the function only has one input value and therefore only one possible output value.</p>
<p>So let us return to <code>getLine</code>. In an imperative language it would look like <code>getLine :: () -&gt; String</code>. Our first problem is that the return value of this function is tainted by the outside world, so we need to use the <code>IO</code> monad, <code>getLine :: () -&gt; IO String</code>. Now because of the isomorphism between unit domian functions and constants we can just write <code>getLine :: IO String</code>. We call a constant of type <code>IO a</code> an &quot;IO action&quot;. Because it stands for a bunch of side effects that will be performed together.</p>
<p>This will seem strange at first, because getLine isn't really a function -- it's just a constant value! But that's okay because while the <code>IO String</code> is a constant (i.e. there is only one distinct IO action that reads a line from the console) the value <em>inside</em> the monad is not constant. It can be different each time we look inside.</p>
<pre class="nocheck" data-language="haskell"><code>&gt; getLine
hello
&quot;hello&quot;

&gt; getLine
monad
&quot;monad&quot;

&gt; getLine &gt;&gt;= (\name -&gt; putStrLn (&quot;Hello &quot; ++ name))
andy
Hello andy</code></pre>
<h2 id="one-thing-leads-to-another">One thing leads to another</h2>
<p>Often when doing IO one wants to make sure one thing happens after another, We can use <code>(&gt;&gt;=)</code> and just ignore the unwrapped value:</p>
<pre class="nocheck" data-language="haskell"><code>putStr &quot;Hello &quot; &gt;&gt;= (\_ -&gt; putStrLn &quot;World&quot;)

putStrLn &quot;One&quot; &gt;&gt;= (\_ -&gt; putStrLn &quot;Two&quot;) &gt;&gt;= (\_ -&gt; putStrLn &quot;Three&quot;)</code></pre>
<p>This pattern can be easily abstracted, it has been standardized as <code>(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b</code>. This can be read as &quot;and then&quot;.</p>
<pre class="nocheck" data-language="haskell"><code>putStr &quot;Hello &quot; &gt;&gt; putStrLn &quot;World&quot;

putStrLn &quot;One&quot; &gt;&gt; putStrLn &quot;Two&quot; &gt;&gt; putStrLn &quot;Three&quot;</code></pre>
<pre class="instruction"><code>

Write a program that prints something stupid, funny or rude.

Make sure to use (&gt;&gt;) somewhere.</code></pre>
<h2 id="monad-wars-iii-return-of-the-value">Monad Wars III: Return of the Value</h2>
<p>We mentioned before that there is no way to untaint a value, once it has been tainted, we can make new tainted values from it, but never untainted ones. But that begs the question, can we choose to taint a value? Indeed we can, in fact, this is a fundamental operation of a Monad. In haskell it is confusingly called <code>return :: a -&gt; IO a</code>.</p>
<pre class="note"><code>In recent versions of GHC (&gt;= 7.10), Monads must also be
Applicative, with the default implementation of `return`
being Applicative&#39;s `pure`.</code></pre>
<p>A common pattern is to &quot;open up&quot; an <code>IO</code> with bind <code>(&gt;&gt;=)</code>, mess around with the contents then wrap it back up again with <code>return</code>. We have a function to help us with this called <code>liftM</code>. Specialized for <code>IO</code> it has type <code>liftM :: (a -&gt; b) -&gt; (IO a -&gt; IO b)</code>. We can use this to take a vanilla function and &quot;lift&quot; it into the IO monad. It works by unwrapping the IO monad calling our function and then wrapping the result back up again.</p>
<pre class="instruction"><code>use return to write &#39;myLiftIO :: (a -&gt; b) -&gt; IO a -&gt; IO b&#39;</code></pre>
<h2 id="do-it-do-it-good.">Do it, do it good.</h2>
<p>Sometimes when you are doing a lot of ad-hoc interleaved IO, using bind and return all over the place can become a pain in the fingers. So haskell provides special syntax for using monads, called &quot;do notation&quot;.</p>
<p>To use do notation, we start a &quot;do block&quot; with the keyword <code>do</code>. Inside a do block, statements can be written line by line and they are automatically joined using &quot;and then&quot; <code>(&gt;&gt;)</code>. This causes them to be run one after the other like in an imperative programming language. One can also easily unwrap monad values and bind them to a variable with using a left arrow &quot;&lt;-&quot; syntax.</p>
<pre class="nocheck" data-language="haskell"><code>  main = do
    putStrLn &quot;Hello World&quot;
    putStrLn &quot;Enter your name: &quot;
    name &lt;- getLine
    putStrLn (&quot;Hello: &quot; ++ name)</code></pre>
<p>The do-notation is like a DSL, under the hood it is just expanded to a chain of bind <code>(&gt;&gt;=)</code> calls. Here is what the above code would look like without do-notation:</p>
<pre class="nocheck" data-language="haskell"><code>  main  =
    putStrLn &quot;Hello World&quot; &gt;&gt;
    putStrLn &quot;Enter your name: &quot; &gt;&gt;
    getLine &gt;&gt;= (\ name -&gt;
      putStrLn (&quot;Hello: &quot; ++ name))</code></pre>
<pre class="instruction"><code>

Write a program that asks for someone&#39;s first and second name,
then compliments them (or makes fun of them).

For extra points ask for their age, and customize the complement
(or insult) depending on how old they are.

Do it with do-notation first, then &quot;desugar&quot; it into raw bind (&gt;&gt;=) calls</code></pre>
<pre class="instruction"><code>

My father once told me about an &quot;amazing AI&quot; that his
magician/programmer friend build, which could answer any yes/no
question as well as a human.

Of course it only worked if his friend was the one typing
the question! The trick being that it just counted the
number of spaces in the question. If there was an even number
it would output true, if there was an odd number, false.
You just fiddled with the wording, or snuck in an extra space,
to get the answer that you wanted...

Looks like it&#39;s time to write your super-dooper
human-level AI and see if your friends can figure
out how it works.</code></pre>
<h2 id="stay-functional-san-diego">Stay Functional, San Diego</h2>
<p>Even when we are programming with side effects, we still want our programs to follow functional principles. To stop our code ending up like C written in do-notation, there are some principles we can try to follow:</p>
<ol style="list-style-type: decimal">
<li><p>Try to do most of the work inside pure functions.</p></li>
<li><p>Don't create an IO action until the last possible moment.</p></li>
<li><p>Be declarative, think of program as declaring a pipeline or specifying an interaction, instead of being a to-do list.</p></li>
<li><p>Avoid mixing control, state and calculation. Instead abstract them into small composable pieces. For inspiration see the monad combinators in Control.Monad (e.g. <code>sequence</code>, <code>forever</code>, <code>mapM</code>).</p></li>
</ol>
<p>These principles are not specific to monads. They are applicable to all side-effect heavy programing problems. These principles can also be applied to imperative programs for great justice.</p>
<p>A lot of patterns like reactive programming, dataflow programming and CQRS are consequences of following principles such as these.</p>
<p>The pithy take-away is don't &quot;update, execute, update&quot;. Instead &quot;represent, transform, compose&quot;.</p>
<pre class="open"><code>An open-ended question:

Why is it a good idea to make side effects explicit?</code></pre>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="lets-make-a-guessing-game">Let's Make a Guessing Game</h1>
<div class="important">
<h2 id="the-game">The Game</h2>
<p>Your task is to make a guessing game where the computer comes up with a number, and you have to make guesses - with the computer telling you if you were too high, or too low.</p>
<h2 id="lexicon">Lexicon</h2>
<table>
<thead>
<tr class="header">
<th align="left">-----------</th>
<th align="left">-------------</th>
<th align="left">------------</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Game</td>
<td align="left">Stack</td>
<td align="left">main</td>
</tr>
<tr class="even">
<td align="left">print</td>
<td align="left">System.Random</td>
<td align="left">randomRIO</td>
</tr>
<tr class="odd">
<td align="left">readLn</td>
<td align="left">compare</td>
<td align="left">case</td>
</tr>
<tr class="even">
<td align="left">do</td>
<td align="left">Procedure</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<h2 id="example-session">Example Session</h2>
<pre><code>$ stack exec -- runhaskell Module_1470214643_41323.hs
&quot;Let&#39;s play the number guessing game&quot;
&quot;Enter a number&quot;
2
&quot;Too low :(&quot;
&quot;Enter a number&quot;
8
&quot;Too high :(&quot;
&quot;Enter a number&quot;
5
&quot;Too high :(&quot;
&quot;Enter a number&quot;
4
&quot;You win!&quot;</code></pre>
</div>
<h2 id="solution-toolbox">Solution Toolbox</h2>
<p>In order to solve the problem the following should be used:</p>
<table>
<thead>
<tr class="header">
<th align="left">Tool</th>
<th align="left">Details</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">main</td>
<td align="left">You must define a <code>main</code> function in your module</td>
</tr>
<tr class="even">
<td align="left">print</td>
<td align="left">Lets you <code>print</code> things to the console</td>
</tr>
<tr class="odd">
<td align="left">System.Random</td>
<td align="left">import System.Random to get access randomRIO</td>
</tr>
<tr class="even">
<td align="left">randomRIO</td>
<td align="left">Generates a random number from a range as an IO action</td>
</tr>
<tr class="odd">
<td align="left">readLn</td>
<td align="left">read a value from the console as a number</td>
</tr>
<tr class="even">
<td align="left">compare</td>
<td align="left"><code>compare x y</code> tells you if <code>x</code> is LT, EQ, or GT <code>y</code></td>
</tr>
<tr class="odd">
<td align="left">case</td>
<td align="left">Dispatch on a value</td>
</tr>
<tr class="even">
<td align="left">do</td>
<td align="left">Execute multiple IO actions</td>
</tr>
</tbody>
</table>
<h2 id="thinking-functionally">Thinking Functionally</h2>
<p>Try to build the solution piece-by-piece. Examine how you can use recursion in conjunction with pattern-matching to keep re-running a procedure until a condition is satisfied.</p>
<div class="important">
<h2 id="solution">Solution</h2>
<p>If you're having trouble coming up with the solution, then here are some hints!</p>
<h3 id="main">Main</h3>
<pre class="answer" data-language="haskell"><code>main :: IO ()
main = do
    print &quot;Let&#39;s play the number guessing game&quot;
    n &lt;- randomRIO (1, 10)
    game n</code></pre>
<h3 id="game">Game</h3>
<pre class="answer" data-language="haskell"><code>game :: Int -&gt; IO ()
game n = do
    print &quot;Enter a number&quot;
    g &lt;- readLn
    case compare g n
      of LT -&gt; tooLow  n
         GT -&gt; tooHigh n
         EQ -&gt; print &quot;You win!&quot;</code></pre>
<h3 id="too-low">Too Low</h3>
<pre class="answer" data-language="haskell"><code>tooLow :: Int -&gt; IO ()
tooLow n = do
  print &quot;Too low :(&quot;
  game n</code></pre>
<h3 id="full-solution">Full Solution</h3>
<pre class="answer" data-language="haskell" data-filter="resources/scripts/check.sh"><code>import System.Random

main :: IO ()
main = do
    print &quot;Let&#39;s play the number guessing game&quot;
    n &lt;- randomRIO (1, 10)
    game n

game :: Int -&gt; IO ()
game n = do
    print &quot;Enter a number&quot;
    g &lt;- readLn
    case compare g n
      of LT -&gt; tooLow  n
         GT -&gt; tooHigh n
         EQ -&gt; print &quot;You win!&quot;

tooLow :: Int -&gt; IO ()
tooLow n = do
  print &quot;Too low :(&quot;
  game n

tooHigh :: Int -&gt; IO ()
tooHigh n = do
  print &quot;Too high :(&quot;
  game n
</code></pre>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>

<h1 id="website">Making a Web-Site with Scotty</h1>
<p>The Haskell library <a href="http://hackage.haskell.org/package/scotty">Scotty</a> is similar to the ruby web-library <a href="http://www.sinatrarb.com/">Sinatra</a>.</p>
<div class="center">
<div class="figure">
<img src="resources/images/scotty.png" alt="Beam me Up" />
<p class="caption">Beam me Up</p>
</div>
</div>
<p>Scotty can be installed by using the following Stack command:</p>
<pre class="shell"><code>&gt; stack install scotty</code></pre>
<p>Scotty's behaviour is based around <a href="http://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> verbs and routes.</p>
<p>For example - A simple Hello-World website:</p>
<pre class="nocheck" data-language="haskell"><code>{-# LANGUAGE OverloadedStrings #-}

import Web.Scotty
import Data.Monoid

main = scotty 3000 $ do
  get &quot;/:word&quot; $ do
    beam &lt;- param &quot;word&quot;
    html $ mconcat [&quot;&lt;h1&gt;Scotty, &quot;, beam, &quot; me up!&lt;/h1&gt;&quot;]</code></pre>
<pre class="note"><code>The &quot;LANGUAGE&quot; line is a pragma, instructing the compiler to
allow string literals to be of types other than &quot;String&quot;.</code></pre>
<p>If we inspect the type of <code>get</code> in GHCi we see this:</p>
<pre class="ghci"><code>&gt; import Web.Scotty
&gt; :info get
get :: RoutePattern -&gt; ActionM () -&gt; ScottyM ()</code></pre>
<p>The ActionM Monad allows us to perform any IO action we desire, such as printing to the console, reading files, etc - through the use of the liftIO function.</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>{-# LANGUAGE OverloadedStrings #-}

import Web.Scotty
import Control.Monad.IO.Class
import Data.Monoid

myRoute = get &quot;/hello&quot; $ do
  liftIO $ putStrLn &quot;about to return hello!&quot;
  html &quot;Hi!&quot;

Error compiling example:

&gt; PANDOCTOR_COUNT=1 data_language=haskell data_filter=./resources/scripts/check.sh

~~~&gt; {-# LANGUAGE OverloadedStrings #-}
~~~&gt; 
~~~&gt; import Web.Scotty
~~~&gt; import Control.Monad.IO.Class
~~~&gt; import Data.Monoid
~~~&gt; 
~~~&gt; myRoute = get &quot;/hello&quot; $ do
~~~&gt;   liftIO $ putStrLn &quot;about to return hello!&quot;
~~~&gt;   html &quot;Hi!&quot;
~~~&gt; main = undefined

[1 of 1] Compiling Main             ( /tmp/haskell_workshop_check.hs, /tmp/haskell_workshop_check.o ) [flags changed]

/tmp/haskell_workshop_check.hs:3:1: error:
    Failed to load interface for ‘Web.Scotty’
    Use -v to see a list of the files searched for.
</code></pre>
<pre class="instruction"><code>Modify this simple website to show the current time.</code></pre>
<pre class="hint"><code>Install the &quot;time&quot; package and &quot;import Data.Time.Clock&quot;.
Use &quot;show&quot; to convert the time to a String.
Use the pack function from &quot;import Data.Text.Lazy (pack)&quot;.
&quot;pack&quot; can convert Strings to Text.</code></pre>
<pre class="answer"><code>First install the &quot;time&quot; package.

Then define your route as:

import Data.Time.Clock
import Data.Text.Lazy (pack)

myTimeRoute = get &quot;/time&quot; $ do
  t &lt;- liftIO getCurrentTime
  html $ pack $ show t

-- You can find a full file in the scaffold/website folder.</code></pre>
<pre class="instruction"><code>

Modify this simple website to output the answers from the
other chapters in this workshop!</code></pre>
<pre class="open"><code>An open question:

What features do the more advanced Haskell web-frameworks include
that Scotty lacks?</code></pre>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="thanks">Thanks!</h1>
<p>We hope you've had a great time today and learned something useful!</p>
<p>We couldn't have put this together without the help of our volunteers, and RMIT for providing the venue!</p>
<p>Thanks a lot for coming along today and if you've developed a taste for Haskell then please consider coming along to the <a href="https://www.meetup.com/Melbourne-Haskell-Users-Group/">Melbourne Haskell User's Group Meetup.</a></p>
<p>MHUG runs monthly at <a href="http://silverpond.com.au/">Silverpond</a> a machine-learning consultancy who not-coincidentally also <a href="http://silverpond.com.au/workshops">run workshops</a>.</p>

</div>
</div>


			<hr>
			<p class="center footer"> Produced with
				<a href="http://johnmacfarlane.net/pandoc/">Pandoc</a>
				- Source on
				<a href="https://github.com/composeconference/compose_haskell_workshop">GitHub</a>
			</p>
		</div>
		<script type="text/javascript" src="resources/javascript/rainbow-custom.min.js"></script>
		<script type="text/javascript" src="resources/javascript/answers.js"></script>
		<script type="text/javascript" src="resources/javascript/collapse.js"></script>
		<script type="text/javascript" src="resources/javascript/sum_times.js"></script>
	</body>
</html>
